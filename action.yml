name: Compute Bumped Version
description: >
  Computes the next semantic version based on commit messages and changed files since the last version tag.

inputs:
  force-patch-if-no-commit-token:
    description: Force patch bump if no [major], [minor], [patch], or [fix] found in commit message(s)
    required: false
    default: "false"
  ignore-paths:
    description: Newline-delimited list of file/directory globs to ignore when checking changed files
    required: false
    default: ""
  version-style:
    description: |
      Your project's style of versioning. 
      Example: 'X.Y.Z' (default), 'X.Y' (no patch segment)
    type: choice
    options:
      - 'X.Y.Z'
      - 'X.Y'
    required: false
    default: 'X.Y.Z'

outputs:
  version:
    description: The next semantic version (empty string if no bump is needed)
    value: ${{ steps.output-version.outputs.version }}

runs:
  using: "composite"
  steps:
    - name: Confirm most recent commit
      shell: bash
      run: |
        # step: Confirm most recent commit
        set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

        git fetch --tags &> /dev/null
        if git status -sb | grep behind; then
          echo "::warning::This commit is not the most recent on this branch — rest of workflow should be halted."
          echo "IS_DONE=true" >> "$GITHUB_ENV"
        fi

    - name: Get the latest version tag
      if: env.IS_DONE != 'true'
      shell: bash
      env:
        VERSION_STYLE: ${{ inputs.version-style }}
      run: |
        # step: Get the latest version tag
        set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

        git fetch --tags &> /dev/null

        case "${VERSION_STYLE}" in
          'X.Y.Z')
            _re='^v?[0-9]+\.[0-9]+\.[0-9]+$'
            ;;
          'X.Y')
            _re='^v?[0-9]+\.[0-9]+$'
            ;;
          *)
            echo "::error::Unsupported version-style: ${VERSION_STYLE}"
            exit 1
            ;;
        esac

        #
        # Use for-each-ref for robust tag listing/sorting
        #
        _latest_version_tag=$(
          git for-each-ref --sort=-creatordate --format='%(refname:strip=2)' refs/tags |
          grep -E "${_re}" | head -n1 || true
        )
        echo "Latest tag (style ${VERSION_STYLE}): ${_latest_version_tag:-}"

        # Explicitly export (even if empty)
        echo "LATEST_VERSION_TAG=${_latest_version_tag:-}" >> "$GITHUB_ENV"

    - name: Handle no previous tag (first release case)
      if: env.IS_DONE != 'true' && env.LATEST_VERSION_TAG == ''
      shell: bash
      env:
        VERSION_STYLE: ${{ inputs.version-style }}
      run: |
        # step: Handle no previous tag (first release case)
        set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

        case "${VERSION_STYLE}" in
          'X.Y.Z') seed="0.0.0" ;;
          'X.Y')   seed="0.0"   ;;
          *) echo "::error::Unsupported version-style: ${VERSION_STYLE}"; exit 1 ;;
        esac

        echo "No previous tag found for style ${VERSION_STYLE} — using ${seed}."
        echo "VERSION=${seed}" >> "$GITHUB_ENV"
        echo "IS_DONE=true" >> "$GITHUB_ENV"

    - name: Validate latest version-tag commit ancestry
      if: env.IS_DONE != 'true'
      shell: bash
      run: |
        # step: Validate latest version-tag commit ancestry
        set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

        _latest_ver_tag_sha=$(git rev-parse "$LATEST_VERSION_TAG")
        echo "Latest version-tag SHA: $_latest_ver_tag_sha"

        # Case 1: does this tag already point to $GITHUB_SHA?
        if [[ "$_latest_ver_tag_sha" == "$GITHUB_SHA" ]]; then
          echo "::warning::This commit ($GITHUB_SHA) is already tagged ($LATEST_VERSION_TAG) — no bump needed."
          echo "VERSION=" >> "$GITHUB_ENV"
          echo "IS_DONE=true" >> "$GITHUB_ENV"
          exit 0
        fi

        # Case 2: is the tag older (and in same linear history) as $GITHUB_SHA?
        if ! git merge-base --is-ancestor "$_latest_ver_tag_sha" "$GITHUB_SHA"; then
          echo "::warning::The latest version tag ($LATEST_VERSION_TAG -> $_latest_ver_tag_sha) is not an ancestor of this commit ($GITHUB_SHA)."
          echo "::warning::This suggests the tag may be from a newer commit — cannot bump version."
          echo "VERSION=" >> "$GITHUB_ENV"
          echo "IS_DONE=true" >> "$GITHUB_ENV"
          exit 0
        fi

    - name: Find first commit since latest version tag
      if: env.IS_DONE != 'true'
      shell: bash
      run: |
        # step: Find first commit since latest version tag
        set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

        FIRST_COMMIT=$(git rev-list -n 1 "$LATEST_VERSION_TAG")
        
        echo "Looking at what's changed since $LATEST_VERSION_TAG / $FIRST_COMMIT..."
        echo
        
        echo "FIRST_COMMIT=$FIRST_COMMIT" >> "$GITHUB_ENV"

    - name: Compute next version
      if: env.IS_DONE != 'true'
      env:
        FORCE_PATCH_IF_NO_COMMIT_TOKEN: ${{ inputs.force-patch-if-no-commit-token }}
        IGNORE_PATHS: ${{ inputs.ignore-paths }}
        FIRST_COMMIT: ${{ env.FIRST_COMMIT }}
        VERSION_STYLE: ${{ inputs.version-style }}
        LATEST_VERSION_TAG: ${{ env.LATEST_VERSION_TAG }}
      shell: bash
      run: |
        # step: Compute next version
        set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

        pip install -r ${{ github.action_path }}/requirements.txt

        VERSION=$(python ${{ github.action_path }}/compute_next_version.py)
        echo "Computed version: $VERSION"
        echo "VERSION=$VERSION" >> "$GITHUB_ENV"

    - id: output-version
      if: env.IS_DONE != 'true' || env.VERSION != ''
      shell: bash
      run: |
        # step: output-version
        set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

        #
        # last minute check that branch has not been updated
        #

        git fetch &> /dev/null
        if git status -sb | grep behind; then
          echo "::warning::This commit is no longer the most recent — aborting."
          exit 0
        fi

        #
        # output!
        #

        if [ -z "${{ env.VERSION }}" ]; then
          echo "No version bump needed."
          echo "version=" >> "$GITHUB_OUTPUT"
        else
          echo "Next version: ${{ env.VERSION }}"
          echo "version=${{ env.VERSION }}" >> "$GITHUB_OUTPUT"
        fi
